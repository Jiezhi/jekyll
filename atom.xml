<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jiezhi Blog</title>
  
  <subtitle>好记性不如烂笔头</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jiezhi.github.io/"/>
  <updated>2019-02-19T08:43:56.492Z</updated>
  <id>http://jiezhi.github.io/</id>
  
  <author>
    <name>Jiezhi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GraphQL简介</title>
    <link href="http://jiezhi.github.io/2018/06/10/graphql/"/>
    <id>http://jiezhi.github.io/2018/06/10/graphql/</id>
    <published>2018-06-10T07:02:51.000Z</published>
    <updated>2019-02-19T08:43:56.492Z</updated>
    
    <content type="html"><![CDATA[<p>GraphQL会是取代REST API的下一代标准么？</p><a id="more"></a><h1 id="什么是GraphQL"><a href="#什么是GraphQL" class="headerlink" title="什么是GraphQL"></a>什么是GraphQL</h1><p><img src="http://qn-cdn.nospider.net/2018-06-10-graphql.png" alt="graphql"></p><blockquote><p>GraphQL是比REST更高效、强大和灵活的新一代API标准。Facebook开发了GraphQL并且将其开源，目前其由一大群来自全球各地的公司和个人维护。</p></blockquote><p>注意到GraphQL是API标准，不要看到QL结尾就以为其是一种数据库技术。</p><h2 id="比REST更灵活的一种选择"><a href="#比REST更灵活的一种选择" class="headerlink" title="比REST更灵活的一种选择"></a>比REST更灵活的一种选择</h2><p>REST是目前比较流行的一种暴露服务端数据的常见方式，其简化了客户端尤其是移动端和服务器交互的流程。但是随着业务变得复杂，有些情况变得棘手：</p><ol><li><p>移动端数量的增多，对数据的效率要求变高<br>移动端和PC端相比，是需要提高对数据获取的效率的，这个效率就是说要减少网络请求、要减少无用数据的传输。</p></li><li><p>应对复杂的前端框架和平台<br>现在的情况是仅维护一套API来应对不同框架和平台的请求。PC端一个页面比移动端一个页面展示的内容要多很多，之前后端提供给PC端的API如果直接提供给移动端来使用势必造成资源浪费。所以移动端的人会去找后端的人干一架，结果要么是后端再给移动端单独写一套API，要么就是移动端忍受着API请求返回数据中存在大量冗余的数据。</p></li><li><p>需要更快速地迭代更新<br>互联网时代最大的特色除了加班也许就是快了。好多公司在喊着小步快跑、快速试错，毕竟市场不等人。然而REST标准的API似乎很难快速地跟上这快跑的节奏。也许一个API刚出来，产品那边已经改了原型，界面重新设计了。这时候就要麻烦后端同学加个班把接口改一下吧。</p></li></ol><h2 id="谁在用GraphQL"><a href="#谁在用GraphQL" class="headerlink" title="谁在用GraphQL"></a>谁在用GraphQL</h2><p>一个产品的流行，肯定是解决了目前的某些痛点。虽然GraqhQL目前在国内还不算流行，可是在美利坚已经有不少巨头在使用了：</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://qn-cdn.nospider.net/2018-06-10-15286168671382.jpg" alt=""></h2><h1 id="GraphQL-vs-REST"><a href="#GraphQL-vs-REST" class="headerlink" title="GraphQL vs REST"></a>GraphQL vs REST</h1><p>我们来看一下对于不同API标准下，从服务端获取数据的区别。比如在REST API标准下，有三个接口：</p><ul><li><p>/users/<id><br>该接口返回某用户基本信息</id></p></li><li><p>/users/<id>/posts<br>该接口返回某用户所有的文章</id></p></li><li><p>/users/<id>/followers<br>该接口返回某用户所有的关注者</id></p></li></ul><p><img src="http://qn-cdn.nospider.net/2018-06-10-15286174419940.jpg" alt=""></p><p><em>如图所示，要通过三个不同的请求才能获得某用户及其文章和关注者的信息，其中还存在很多不需要的信息。 </em></p><p>再看一下GraphQL API的实现：<br><img src="http://qn-cdn.nospider.net/2018-06-10-15286175800503.jpg" alt=""><br><em>客户端声明自己想要的信息，然后服务端根据请求返回相应的数据</em></p><p>目前可见的优点：</p><ol><li>避免了REST API中常见的信息过多或过少的问题<br>信息过多是指，接口中总会存在客户端不需要的信息，信息过少是指单条接口无法满足客户端需求，需要请求多个接口才能满足需要</li><li><p>前端可以快速迭代<br>在REST API中，一般都是后端定义好了API，返回固定的数据格式。当前端业务或需求发生变化时，后端很难跟上变动的节奏。如今，业务变化已经难以避免，所以当前端和后端都要相应地作出改动，这样效率势必降低。就我们公司业务来讲，很多情况下，前端一两天的改动如果再拉上后端，人多肯定要开会再加上沟通成本的问题，这个需求没个一周两周很难搞定。设想一下，如果在GraphQL标准下，除非大的改版，后端基本不用出人力来跟着一起需求评审，前端自己定义查询的内容就搞定了。</p></li><li><p>更深层次地进行分析<br>当客户端可以选择自己想请求数据的内容时，这时候就可以分析出哪些信息是用户感兴趣的，也可以更深层次地分析现有数据是如何被应用的。<br>此外，也可以分析出哪些信息用户不再感兴趣了。</p></li><li><p>Schema &amp; Type系统的优点<br>GraphQL使用一种强类型系统来定义API，所有的API都通过GraphQL模式定义语言（Schema Definition Language，SDL）来暴露类型数据。而这个模式就是服务端和客户端之间的协议，通过此模式我们可以知道服务端可以提供哪些数据，而客户端又可以获取哪些数据。</p></li></ol><p>一旦模式定义好了，前后端就可以据此独立进行开发了。</p><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="模式定义语言（The-Schema-Definition-Language，SDL）"><a href="#模式定义语言（The-Schema-Definition-Language，SDL）" class="headerlink" title="模式定义语言（The Schema Definition Language，SDL）"></a>模式定义语言（The Schema Definition Language，SDL）</h2><p>比如这里定义了一个<code>Person</code>类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Person &#123;</span><br><span class="line">  name: String!</span><br><span class="line">  age: Int!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person类型又两个字段，<code>name</code>和<code>age</code>，分别为<code>String</code>和<code>Int</code>类型。<code>!</code>表示该字段是必须的。</p><p>同时，两种类型之间可以有关联，比如<code>Person</code>可以和<code>Post</code>关联：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Post &#123;</span><br><span class="line">title: String!</span><br><span class="line">author: Person!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的，<code>Person</code>中也可以关联<code>Post</code>类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type Person &#123;</span><br><span class="line">name: String!</span><br><span class="line">age: Int!</span><br><span class="line">posts: [Post!]!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>Person</code>和<code>Post</code>是一对多的关系</p><h2 id="通过Queries获取数据"><a href="#通过Queries获取数据" class="headerlink" title="通过Queries获取数据"></a>通过Queries获取数据</h2><p>在请求数据之前，你需要GraphQL-IDE来模拟下面的请求，有<a href="https://api.graph.cool/simple/v1/cjhvs1vtt4ahm012322aexl4n/?query=%7B%0A%20%20allPersons%20%7B%0A%20%20%20%20name%0A%20%20%7D%0A%7D" target="_blank" rel="noopener">Web版</a> 也有<br><a href="https://github.com/graphcool/graphql-playground" target="_blank" rel="noopener">客户端</a> </p><p>如果你选择了客户端，在启动页面打开这个地址： <a href="https://api.graph.cool/simple/v1/cjhvs1vtt4ahm012322aexl4n/" target="_blank" rel="noopener">https://api.graph.cool/simple/v1/cjhvs1vtt4ahm012322aexl4n/</a></p><p><img src="http://qn-cdn.nospider.net/2018-06-10-15286229140756.jpg" alt=""></p><p>让我们来一个最简单的请求：</p><p><img src="http://qn-cdn.nospider.net/2018-06-10-15286230297031.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  allPersons &#123;</span><br><span class="line">    name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到返回的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;allPersons&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;Johnny&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;Sarah&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;Alice&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;Bob&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;Alice&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想在结果里带上age的话：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  allPersons &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://qn-cdn.nospider.net/2018-06-10-15286232389082.jpg" alt=""></p><h3 id="带参请求"><a href="#带参请求" class="headerlink" title="带参请求"></a>带参请求</h3><p>同样没问题，可以看到只返回了最后两条数据：<br><img src="http://qn-cdn.nospider.net/2018-06-10-15286233483934.jpg" alt=""></p><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>这里说的修改包含三种操作：</p><ul><li>创建数据</li><li>更新数据</li><li>删除数据</li></ul><p>这里以创建数据为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutation &#123;</span><br><span class="line">  createPerson(name: &quot;Bob&quot;, age: 36) &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://qn-cdn.nospider.net/2018-06-10-15286234981761.jpg" alt=""></p><h2 id="订阅实时更新"><a href="#订阅实时更新" class="headerlink" title="订阅实时更新"></a>订阅实时更新</h2><p>GraphQL提供了<code>subscriptions</code>的概念来提供给客户端订阅事件。当客户端订阅某事件后，其将会和服务端保持一个稳定的链接。当特定事件触发时，服务端会推送对应的数据给客户端。</p><p>比如我们想订阅新建<code>Person</code>类型事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">subscription &#123;</span><br><span class="line">  newPerson &#123;</span><br><span class="line">    name</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有新的Person类型被创建时，客户端就能接收到更新的数据了。</p><h2 id="定义模式"><a href="#定义模式" class="headerlink" title="定义模式"></a>定义模式</h2><p>模式是GraphQL API中最重要概念之一，其定义了API能提供哪些数据，以及客户端如何获取这些数据。</p><p>有几个特殊的类型被称之为<code>root</code>类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123; ... &#125;</span><br><span class="line">type Mutation &#123; ... &#125;</span><br><span class="line">type Subscription &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>本文中用到的完整模式定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  allPersons(last: Int): [Person!]!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Mutation &#123;</span><br><span class="line">  createPerson(name: String!, age: Int!): Person!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Subscription &#123;</span><br><span class="line">  newPerson: Person!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Person &#123;</span><br><span class="line">  name: String!</span><br><span class="line">  age: Int!</span><br><span class="line">  posts: [Post!]!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Post &#123;</span><br><span class="line">  title: String!</span><br><span class="line">  author: Person!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>至此，大家应该对GraphQL有一个感性的认识了吧。如果不想仅停留在概念层面，你可以到<a href="https://graphql.org/code/gg" target="_blank" rel="noopener">这里</a>找到目前已经实现的框架。（反正我已经用起来了:P）<br><img src="http://qn-cdn.nospider.net/2018-06-10-15286245421358.jpg" alt=""></p><p>更多内容可访问以下网站：</p><p><a href="https://www.graphql.org/" target="_blank" rel="noopener">https://www.graphql.org/</a><br><a href="https://www.howtographql.com/" target="_blank" rel="noopener">https://www.howtographql.com/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GraphQL会是取代REST API的下一代标准么？&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我与阅读</title>
    <link href="http://jiezhi.github.io/2018/03/25/book-app/"/>
    <id>http://jiezhi.github.io/2018/03/25/book-app/</id>
    <published>2018-03-25T14:03:38.000Z</published>
    <updated>2019-02-19T08:37:22.846Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下自己读书历程，并推荐一下自己用得比较多的阅读相关的APP。</p><a id="more"></a><p>从小到大就自诩自己是个喜欢阅读的人，一方面可能是我们家族在村子里算是有文化的人吧，遗传了一点（听说我爷爷的爷爷是私塾老师，现在大家子里当老师的也挺多的），另一方面可能因为小时候偏内向，所以较多的时候都是个安静的男孩子，就喜欢翻翻书什么的。</p><p>记得小学的时候就喜欢找那些初中生的那些阅读课本看，实在没得看就翻成语词典或新华字典了。到了中学，因为镇上没有书店，就经常坐公交去县城买书看。那时候公交车单程要3块钱，对于一周也才几块钱零花钱的我压力实在不小，然后就会顺路帮同学们买点资料什么的，顺便把路费给平摊了。那时候有个『龙门书局』的出版社，感觉挺酷的，就给自己起了个『星星书局』，并用橡皮刻了章，然后印在了每一本书上。</p><p>高中进了县城去了，高一时语文老师给我们解释了什么是『语文』：</p><blockquote><p>语为心声，文以载道</p></blockquote><p>正好那时候学校给每个年级配备了阅览室，里面有不少的杂志和文学书籍可以在里面看。那时候我下课就会跑过去，阅览室的老师对我这个为数不多的读者印象很好，就特批我可以把书带回去看，时间长了甚至让我帮她看着阅览室。这种有特权的感觉让我这个大男孩有点小骄傲，所以更是经常跑去借书看了。由于新校区才建立不久，所以没有图书馆。那时候最大的愿望就是能天天泡图书馆，听说大学里图书馆特别多，所以还是比较期待上大学的。</p><p>嗯，上了大学，还没拿到学生卡就开始往图书馆跑了，想着大学4年一定要看多少多少的书来着。天有不测风云，谁能想到，我看的书基本都是计算机类的书了。由于学校是医药类学校，虽然有信息学院，但可以肯定的是，真正对计算机感兴趣的实在不多。所以据我不完全观察，TP类书架大部分时间只有我一个人在那里看书。偶尔有几个妹子走那里停留，不用想是在找计算机等级考试的参考资料。就这样，在毕业的时候，学校第一次评选书虫奖，忘了自己读了多少书了，反正排在那一届第9名，平均一周一本书的进度吧（具体数据要等我找到当时的证书再修正）。</p><p>总体看来，对我影响比较大的老师基本都是语文老师，小学时被语文老师夸知道的成语多，然后我就使劲得翻成语词典；初中时被语文老师夸读的课外书多，我就使劲地找课外书读；高中时被语文老师夸…想不起来了，但是我使劲地背古诗词了，然后也写了几篇诗词，也模仿过汪曾祺先生写过几篇文章。至于大学时嘛，由于没有语文老师，然后我就基本上泡图书馆看计算机的书了。</p><p>对于用APP看书，一开始我是排斥的，觉得没有纸质书有感觉，也少了厚重感。那时候被人推荐关注了冯大辉，可能由于他也是医药类专业然后转行搞IT的原因吧。然后用上了他推荐了彼时还没被小米收购的『<strong>多看阅读</strong>』，在然后买了人生中第一本电子书<strong>《海底捞你学不会》</strong>：<br><img src="http://qn-cdn.nospider.net/2018-03-25-15219897449337.jpg" alt=""><br>然后这是当年的评价：<br><img src="http://qn-cdn.nospider.net/2018-03-25-15219898153947.jpg" alt=""><br>那时候才知道电子书除了txt还有epub格式的，还可以有像纸质书一样的排版，里面除了有文字还可以有图片甚至是视频。此后就走上了买电子书的不归路。</p><p>真正体会到电子书的好处，当然还是毕业后搬家了，有过几次搬家，没啥家当图书要占一大半，关键是看起来还不方便。后来我就逢人就推荐看电子书了，开始大部分人都和我当年一样觉得看纸质书有感觉，也以为电子书就是txt，也都不知道电子书是要买的。当然现在还是有不少人，即使工资已经很高了，说到电子书立马去找盗版资源。。。</p><p>废话不多说了，列举一些目前我在用的一些APP：</p><ul><li><p><a href="http://www.duokan.com/" target="_blank" rel="noopener">多看</a><br>说实话对多看是有特殊感情的，毕竟大部分书就是在多看买的，那时候多看还不是小米系的，那时候排版是最好的，那时候根本没有网文，那时候kindle还可以刷多看的。目前除了看《知乎周刊》和一些理财类的杂志，基本上就是看以前买的书了。</p></li><li><p><a href="https://du.163.com/invite?user=daa4ce39a9314eeca7e3ec58a28c9675&amp;bg=5&amp;from=singlemessage&amp;isappinstalled=0" target="_blank" rel="noopener">蜗牛读书</a></p></li></ul><blockquote><p>每天免费读书一小时</p></blockquote><p>后起之秀，通过每天免费1小时的创新吸引了不少人，里面也有不少的好书，比如中信出版社的。如果我想看的书在这里有的话就在这里看了，而且虽然每天只能免费1小时，但我相信能满足90%的人了。</p><ul><li><a href="https://weread.qq.com/" target="_blank" rel="noopener">微信阅读</a>  </li></ul><blockquote><p>微信读书让阅读不再孤独.</p></blockquote><p>微信出什么估计都能引起很大的轰动，腾讯利用熟人社交尝到了太多的甜头，微信阅读也不例外。之前多看也想基于阅读做关于读书的圈子，但没多久就做不下去了。对于微信阅读，刚推出的时候排版差、大量重复的段落等让我用了几天就抛之脑后了。但是等过一阶段再去看看，发现情况已经有了很大的改善。此外还有一个特点是每周可以用阅读时间来换取书币，每周最多10个吧。</p><p>上面这几个是目前用的比较多的，此外还有『京东阅读』、『百度阅读』等。</p><p>对于纸质书的话，也有不少APP可以记录阅读状态的，相当于在线书签了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下自己读书历程，并推荐一下自己用得比较多的阅读相关的APP。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker中Django处理消息队列遇到的坑</title>
    <link href="http://jiezhi.github.io/2018/01/05/django-with-mq-in-docker/"/>
    <id>http://jiezhi.github.io/2018/01/05/django-with-mq-in-docker/</id>
    <published>2018-01-05T01:35:47.000Z</published>
    <updated>2019-02-19T08:38:14.143Z</updated>
    
    <content type="html"><![CDATA[<p>早上过来发现昨天上线的代码还是有个问题，好在很快解决了，觉得有必要做个小总结了。</p><a id="more"></a><h4 id="python实现mq消息接收处理"><a href="#python实现mq消息接收处理" class="headerlink" title="python实现mq消息接收处理"></a>python实现mq消息接收处理</h4><h5 id="框架选择"><a href="#框架选择" class="headerlink" title="框架选择"></a>框架选择</h5><p>因为想不到怎么在Django里加上mq消息处理，所以就暴露出一个接口直接来调用。公司使用的是<a href="http://activemq.apache.org/" target="_blank" rel="noopener">activemq</a>，其支持4种协议：</p><blockquote><ul><li><a href="http://activemq.apache.org/openwire.html" target="_blank" rel="noopener">OpenWire</a> for high performance clients in Java, C, C++, C#</li><li><a href="http://activemq.apache.org/stomp.html" target="_blank" rel="noopener">Stomp</a> support so that clients can be written easily in C, Ruby, Perl, Python, PHP, ActionScript/Flash, Smalltalk to talk to ActiveMQ as well as any other popular Message Broker</li><li><a href="http://activemq.apache.org/amqp.html" target="_blank" rel="noopener">AMQP</a> v1.0 support</li><li><a href="http://activemq.apache.org/mqtt.html" target="_blank" rel="noopener">MQTT</a> v3.1 support allowing for connections in an IoT environment.</li></ul></blockquote><p>从中可以看到，最适合python的就是<a href="http://stomp.github.io/index.html" target="_blank" rel="noopener">Stomp</a>协议了。在<a href="http://stomp.github.io/implementations.html" target="_blank" rel="noopener">客户端列表</a>中可以找到不同实现语言对应的客户端，这里我选择了<a href="https://github.com/jasonrbriggs/stomp.py" target="_blank" rel="noopener">stomp.py</a>，谁让他排在搜索页面前面呢（其名称就是一种很好的SEO方式）。</p><h6 id="mq客户端的实现"><a href="#mq客户端的实现" class="headerlink" title="mq客户端的实现"></a>mq客户端的实现</h6><p>这里曾经遇到困扰好几天的坑：</p><ul><li><p><strong>协议的选择</strong></p><p>之前没接触过消息队列这块，天真地以为activemq就是mq的一种协议。豆油给我一个mq服务器地址和端口号（61616）后，使用stomp.py连接总是出错，连接时可以收到mq服务器返回的消息，解析却总是出错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Exception <span class="keyword">in</span> thread StompReceiverThread<span class="number">-1</span>:</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/usr/local/Cellar/python3/3.6.1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/threading.py"</span>, line <span class="number">916</span>, <span class="keyword">in</span> _bootstrap_inner</span><br><span class="line">    self.run()</span><br><span class="line">  File <span class="string">"/usr/local/Cellar/python3/3.6.1/Frameworks/Python.framework/Versions/3.6/lib/python3.6/threading.py"</span>, line <span class="number">864</span>, <span class="keyword">in</span> run</span><br><span class="line">    self._target(*self._args, **self._kwargs)</span><br><span class="line">  File <span class="string">"path/of/project/lib/python3.6/site-packages/stomp.py-4.1.19-py3.6.egg/stomp/transport.py"</span>, line <span class="number">332</span>, <span class="keyword">in</span> __receiver_loop</span><br><span class="line">    f = utils.parse_frame(frame)</span><br><span class="line">  File <span class="string">"path/of/project/lib/python3.6/site-packages/stomp.py-4.1.19-py3.6.egg/stomp/utils.py"</span>, line <span class="number">138</span>, <span class="keyword">in</span> parse_frame</span><br><span class="line">    preamble = decode(frame[<span class="number">0</span>:preamble_end])</span><br><span class="line">  File <span class="string">"path/of/project/lib/python3.6/site-packages/stomp.py-4.1.19-py3.6.egg/stomp/backward3.py"</span>, line <span class="number">29</span>, <span class="keyword">in</span> decode</span><br><span class="line">    <span class="keyword">return</span> byte_data.decode()</span><br><span class="line">UnicodeDecodeError: <span class="string">'utf-8'</span> codec can<span class="string">'t decode byte 0xf0 in position 0: invalid continuation byte</span></span><br></pre></td></tr></table></figure><p>​</p><p>调试几天都是不行，就去提了个<a href="https://github.com/jasonrbriggs/stomp.py/issues/177" target="_blank" rel="noopener">issue</a>。</p><p>后来才发现是activemq实现了四种协议的服务，而不同协议开放的端口号不一样。stomp默认端口号为<strong>61613</strong>，端口号一换立马可以接收到消息。连接问题解决。</p><p>​</p></li><li><p><strong>如何加入到Django里</strong></p><p>被这个问题也是困扰了好久，单独的一个脚本到底如何加入到django里。曾经想过在启动django里随即运行该脚本，却一直找不到方法。因为我想把更多的精力放到对客户分数的处理上，而不是花太多的时间来处理后端的问题。所以比较急着想把这个问题解决，然而越急越无法找到实现的办法，也舍不得花时间来思考是不是这条路是不是对的路。正所谓<strong>我们都在不断赶路忘记了出路</strong>。</p><p>久久无果后，索性第一个版本就没加入消息队列的处理，回头处理数据去！</p><p>这两天忽然想到要不就把接收消息的代码单独拎出来运行，接收到消息就直接调用本地接口就可以了。然后直接用python启动就好了，调用本地接口也OK。</p><p><strong>有时候，被一个问题困扰太久就容易陷进去，不可自拔。</strong></p></li><li><p><strong>又出问题了</strong></p><p>然后把这个接收消息的脚本scp到服务器再运行又出现了2个问题：</p><ol><li>服务器没有python3</li><li>还要安装各种依赖库（会出现各种问题）</li></ol><p>没办法要为这个单独的脚本制作一个docker镜像了，有点高射炮打蚊子的感觉。但是好在可以做到平台无关性，不用去解决各种依赖的问题。</p><p>折腾一通后，可以正常启动运行了。然而天有不测风云，在本地可以正常运行的脚本，到了这里却出错了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; r = requests.delete(<span class="string">'http://0.0.0.0:8000/credit/apply-del/ED201******53'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/usr/local/lib/python3.6/site-packages/urllib3/connection.py"</span>, line <span class="number">141</span>, <span class="keyword">in</span> _new_conn</span><br><span class="line">    (self.host, self.port), self.timeout, **extra_kw)</span><br><span class="line">  File <span class="string">"/usr/local/lib/python3.6/site-packages/urllib3/util/connection.py"</span>, line <span class="number">83</span>, <span class="keyword">in</span> create_connection</span><br><span class="line">    <span class="keyword">raise</span> err</span><br><span class="line">  File <span class="string">"/usr/local/lib/python3.6/site-packages/urllib3/util/connection.py"</span>, line <span class="number">73</span>, <span class="keyword">in</span> create_connection</span><br><span class="line">    sock.connect(sa)</span><br><span class="line">ConnectionRefusedError: [Errno <span class="number">111</span>] Connection refused</span><br></pre></td></tr></table></figure><p>悲剧（被拒）了。</p><p>一开始以为是不是iptables配置的问题，可是没听说过iptables用来防本地访问的呀，在终端里用curl执行了一下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X <span class="string">"DELETE"</span> <span class="string">"http://0.0.0.0:8000/credit/apply-del/ED201******53"</span></span><br><span class="line">&#123;<span class="string">"detail"</span>:<span class="string">"Not found."</span>,<span class="string">"status_code"</span>:404&#125;</span><br></pre></td></tr></table></figure><p>没问题（忽略404），也就是不是防火墙的问题之类的。又怀疑是requests库的问题，又进这个镜像里用python3自带的urllib.request执行也是被拒。正想着难道非要执行curl命令才行？不合常理呀。</p><p>这时候机智的我灵光一现，难不成是在docker里运行的问题？docker就算是一个轻量级的虚拟机了，网络应该默认是<strong>bridge</strong>形式的。</p><p>嗯，改为<strong>–net=host</strong>，搞定！</p></li></ul><h3 id="最后附上处理消息队列的脚本-关键地方已经打码-："><a href="#最后附上处理消息队列的脚本-关键地方已经打码-：" class="headerlink" title="最后附上处理消息队列的脚本(关键地方已经打码)："></a>最后附上处理消息队列的脚本(关键地方已经打码)：</h3>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on 04/12/2017</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: 'Jiezhi.G@gmail.com'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Reference:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> json <span class="keyword">import</span> JSONDecodeError</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> stomp</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.basicConfig(filename=<span class="string">'credit_message.log'</span>, level=logging.DEBUG, format=<span class="string">'%(asctime)s %(message)s'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyListener</span><span class="params">(stomp.ConnectionListener)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_error</span><span class="params">(self, headers, body)</span>:</span></span><br><span class="line">        logging.error(<span class="string">'received an error "%s"'</span> % body)</span><br><span class="line">        print(<span class="string">'received an error "%s"'</span> % body)</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_message</span><span class="params">(self, headers, body)</span>:</span></span><br><span class="line">        logging.info(<span class="string">'\n'</span>)</span><br><span class="line">        logging.info(<span class="string">'received a message "%s"'</span> % body)</span><br><span class="line">        print(<span class="string">'received a message "%s"'</span> % body)</span><br><span class="line">        <span class="comment"># print(body['apply_id'])</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = json.loads(body)</span><br><span class="line">            <span class="keyword">if</span> data[<span class="string">'applyId'</span>]:</span><br><span class="line">                delete_url = <span class="string">'http://0.0.0.0:8000/credit/apply-del/'</span> + data[<span class="string">'applyId'</span>]</span><br><span class="line">                r = requests.delete(delete_url)</span><br><span class="line">                print(r.status_code)</span><br><span class="line">                print(r.content)</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            logging.error(<span class="string">'KeyError process error: %s'</span> % body)</span><br><span class="line">        <span class="keyword">except</span> JSONDecodeError:</span><br><span class="line">            logging.error(<span class="string">'JSONDecodeError process error: %s'</span> % body)</span><br><span class="line">            print(<span class="string">'error:'</span>, body)</span><br><span class="line">  </span><br><span class="line">        logging.info(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">        logging.info(<span class="string">'\n'</span>)</span><br><span class="line">        print(<span class="string">'-'</span> * <span class="number">80</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_connected</span><span class="params">(self, headers, body)</span>:</span></span><br><span class="line">        logging.info(<span class="string">'Connected'</span>)</span><br><span class="line">        print(<span class="string">'Connected'</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_connecting</span><span class="params">(self, host_and_port)</span>:</span></span><br><span class="line">        logging.info(<span class="string">'Connecting'</span>)</span><br><span class="line">        print(<span class="string">'connecting'</span>, host_and_port)</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_disconnected</span><span class="params">(self)</span>:</span></span><br><span class="line">        logging.info(<span class="string">'disconnected'</span>)</span><br><span class="line">        print(<span class="string">'disconnected'</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_heartbeat</span><span class="params">(self)</span>:</span></span><br><span class="line">        logging.info(<span class="string">'heartbeat'</span>)</span><br><span class="line">        print(<span class="string">'heartbeat'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect_mq_server</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># conn = stomp.Connection([('127.0.0.1', 61616)])</span></span><br><span class="line">    <span class="comment"># conn = stomp.Connection11([('192.168.*.*', 61613)])</span></span><br><span class="line">    conn = stomp.Connection11([(<span class="string">'*.1.*.2'</span>, <span class="number">61613</span>)])</span><br><span class="line">    conn.set_listener(<span class="string">''</span>, MyListener())</span><br><span class="line">    conn.start()</span><br><span class="line">  </span><br><span class="line">    conn.connect(<span class="string">'admin'</span>, <span class="string">'password'</span>, wait=<span class="keyword">True</span>)</span><br><span class="line">    conn.subscribe(destination=<span class="string">'queue.bc.rgb.cs.commit.risk'</span>,</span><br><span class="line">                   id=<span class="string">'1'</span>,</span><br><span class="line">                   ack=<span class="string">'auto'</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># conn.send(body='Hello world', destination='/queue/test')</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># conn.disconnect()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    connect_mq_server()</span><br></pre></td></tr></table></figure><p>  以及启动脚本：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">docker run \</span><br><span class="line">           -d \</span><br><span class="line">           --name credit_mq \</span><br><span class="line">           --net=host \</span><br><span class="line">           -v /home/docker/credit_message.log:/app/credit_message.log \</span><br><span class="line">           credit_mq:v1 \</span><br><span class="line">           python handle_message_queue.py</span><br></pre></td></tr></table></figure><p>  算了Dockerfile也放出来吧：</p>  <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /app</span></span><br><span class="line"><span class="bash">WORKDIR /app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY requirements.txt /app/requirements.txt</span></span><br><span class="line"><span class="bash">RUN pip install -r requirements.txt --trusted-host pypi.douban.com -i http://pypi.douban.com/simple</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">COPY . /app</span></span><br><span class="line"><span class="bash">CMD python handle_message_queue.py</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早上过来发现昨天上线的代码还是有个问题，好在很快解决了，觉得有必要做个小总结了。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://jiezhi.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://jiezhi.github.io/tags/python/"/>
    
      <category term="Docker" scheme="http://jiezhi.github.io/tags/Docker/"/>
    
      <category term="Django" scheme="http://jiezhi.github.io/tags/Django/"/>
    
      <category term="mq" scheme="http://jiezhi.github.io/tags/mq/"/>
    
      <category term="stomp" scheme="http://jiezhi.github.io/tags/stomp/"/>
    
  </entry>
  
  <entry>
    <title>2017年总结</title>
    <link href="http://jiezhi.github.io/2018/01/01/2017-summary/"/>
    <id>http://jiezhi.github.io/2018/01/01/2017-summary/</id>
    <published>2018-01-01T13:48:41.000Z</published>
    <updated>2019-02-19T08:42:59.980Z</updated>
    
    <content type="html"><![CDATA[<p>一年一度的总结来了，<del>赶在了2018年到来之前</del>。</p><p>总的来说今年是比较曲折的一年，体会了得与失，也是工作转型的一年。<br><a id="more"></a></p><h1 id="2017年个人总结"><a href="#2017年个人总结" class="headerlink" title="2017年个人总结"></a>2017年个人总结</h1><h2 id="计划完成情况"><a href="#计划完成情况" class="headerlink" title="计划完成情况"></a>计划完成情况</h2><p>去年的总结写得有点迟，都忘记给自己定计划了。这里翻出了<a href="http://jiezhi.github.io/2015/12/28/2015-summary/"><del>15年</del>14年</a>给自己定的计划：</p><blockquote><ol><li>一个月一本书（<em>非技术类</em>）</li><li>坚持锻炼（<em>起码隔三差五</em>）</li><li>坚持记账</li></ol></blockquote><h3 id="一个月一本书"><a href="#一个月一本书" class="headerlink" title="一个月一本书"></a>一个月一本书</h3><p>由于沉迷王者荣耀，一个月一本非技术类的书是远没有达到，这里手指掰一下也就基本《<a href="https://book.douban.com/subject/6811366/" target="_blank" rel="noopener">禅与摩托车维修艺术</a>》、《<a href="https://book.douban.com/subject/1255500/" target="_blank" rel="noopener">动物农场</a>》、《<a href="https://book.douban.com/subject/25902942/" target="_blank" rel="noopener">文明之光（第一册）</a>》、《<a href="https://book.douban.com/subject/26904421/" target="_blank" rel="noopener">征信与大数据</a>》、《<a href="https://book.douban.com/subject/27004031/" target="_blank" rel="noopener">蚂蚁金服</a>》。</p><p>这里自我批评一下，差点上了『奶头乐』的当，还好现在对王者荣耀没那么大的兴趣了，现在比较火的吃鸡游戏也没兴趣，总算是可以挤出时间继续看书了（在内心里摸了摸还在办公桌上吃灰的Kindle）。</p><h3 id="坚持锻炼"><a href="#坚持锻炼" class="headerlink" title="坚持锻炼"></a>坚持锻炼</h3><p>这个似乎从15年就开始松懈了，天天加班到吐再也没心思想什么锻炼的事，所以拖到了现在的公司，天不冷的时候基本会打一两次的篮球。</p><p>到9月份的时候开始和小伙伴下班后绕着园区一起跑步，然后先后相约参加了南京马拉松迷你跑、无锡半程马拉松和苏州半程马拉松。</p><p>此外，近两个月也去了几次健身房做一些力量型的训练。</p><p>总体来说，锻炼方面比之前有长进，希望可以再接再厉。</p><h3 id="坚持记账"><a href="#坚持记账" class="headerlink" title="坚持记账"></a>坚持记账</h3><p>这个的话，坚持有3年了，但是基本是在月底花一个晚上汇总所有的账单。仅仅是记录但是并没有复盘，也没有及时更新预算表，所以那只是一堆数据放在那里，并没有起到太大的作用。所以准备定期复盘。</p><hr><h2 id="学习和工作"><a href="#学习和工作" class="headerlink" title="学习和工作"></a>学习和工作</h2><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><p>一直鞭策自己要成为一个持续学习者，今年坚持了每天都学英语：</p><p>在『百词斩』上背完了<strong>雅思核心单词</strong>，扇贝打卡<strong>365天</strong>。</p><p>当然最近学习的中心放在了机器学习方面，numpy、pandas、matplotlib、scikit、tensorflow都在马不停蹄地学习中。要理解好多的算法还是比较头疼的。</p><p>学完了Andrew Ng的机器学习的课程。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>先看自己<a href="http://jiezhi.github.io/2015/12/28/2015-summary/#%E5%B7%A5%E4%BD%9C">15年的总结</a>：</p><blockquote><p>不得不提的一个感想是，谁也不知道你之前学到的东西就在某天就用上了。在前一家公司下班后吃过饭就开始在<a href="http://jiezhi.github.io/2015/12/28/2015-summary/www.imooc.com">慕课网</a>和<a href="http://jiezhi.github.io/2015/12/28/2015-summary/study.163.com">网易云课堂</a>上学习,期间把python算是入门了，没想到半年后的项目中有很多用到python分析程序的，期间也写了很多脚本。那段时间心里老是念叨『但行好事，莫问前程』，虽不贴切，但我就是念叨这句。<strong>谁知道后面我会不会用python来分析『大』数据或搭建网站呢。</strong>（<em>高呼『生命苦短，我用Python』</em>）</p></blockquote><p>翻到这里，不禁虎躯一震，说得太对了。</p><p>目前公司的业务场景不太需要在移动端进行复杂的运算，所以很多任务都可以用Hybrid方式来开发，一套代码即可。原生开发似乎有点奢侈了，所以在下半年我被单独安排了做<strong>数据分析</strong>这块。</p><p>当然这也正合我意，本来做Android原生开发这块就已经有危机意识了，所以自己本身也在寻求其他的可能。</p><p>期间也第一次正式用Django搭建了一个服务，此前在自己的服务器上随便搭过基于Django的工具类网站。但这倒是第一次用在生产环境，可喜可贺。</p><hr><h2 id="其它关键词"><a href="#其它关键词" class="headerlink" title="其它关键词"></a>其它关键词</h2><ul><li>Macbook Pro 15寸</li><li>iPhone 8 Plus</li><li>iWatch S2</li><li>最强王者</li><li>分手</li><li>复合</li></ul><hr><h2 id="2018年目标"><a href="#2018年目标" class="headerlink" title="2018年目标"></a>2018年目标</h2><ul><li>首付</li><li>结婚</li><li>全马</li><li>67.5kg</li><li>英语/day</li><li>锻炼/week</li><li>一本书/month</li><li>在数据分析上做出点成绩/year</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一年一度的总结来了，&lt;del&gt;赶在了2018年到来之前&lt;/del&gt;。&lt;/p&gt;
&lt;p&gt;总的来说今年是比较曲折的一年，体会了得与失，也是工作转型的一年。&lt;br&gt;
    
    </summary>
    
      <category term="Life" scheme="http://jiezhi.github.io/categories/Life/"/>
    
    
      <category term="2017" scheme="http://jiezhi.github.io/tags/2017/"/>
    
      <category term="总结" scheme="http://jiezhi.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>iPython技巧</title>
    <link href="http://jiezhi.github.io/2017/10/18/ipython/"/>
    <id>http://jiezhi.github.io/2017/10/18/ipython/</id>
    <published>2017-10-18T07:43:12.000Z</published>
    <updated>2019-02-19T08:49:19.808Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下ipython的一些技巧</p><a id="more"></a><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="Introspection"><a href="#Introspection" class="headerlink" title="Introspection"></a>Introspection</h3><ul><li>在对象前或对象后使用问号 <strong>?</strong> ，将会展示该对象的一些基本信息</li><li>如果在一个方法名上使用问号，将会展示该方法的说明文档（docstring）</li><li>使用双问号??将会展示该方法的源码</li><li><p>?和通配符*的搭配使用有奇效：</p><p>  In [100]:np.<em>load</em>?<br>  np.<strong>loader</strong><br>  np.load<br>  np.loads<br>  np.loadtxt<br>  np.pkgload</p></li></ul><h3 id="run-命令"><a href="#run-命令" class="headerlink" title="%run 命令"></a>%run 命令</h3><ul><li>该命令可以在IPython中直接执行Python程序文件。</li></ul><h3 id="paste"><a href="#paste" class="headerlink" title="%paste"></a>%paste</h3><ul><li>执行剪贴板中的代码</li></ul><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p><img src="https://static.notion-static.com/1a3e46659f244dea86a85776cb6e6799/Untitled" alt=""></p><p><img src="https://static.notion-static.com/64b10bbc0c644bbaa4c356fa803c87ee/Untitled" alt=""></p><p>参考</p><ul><li>《Python for Data Analysis》Chapter 3</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下ipython的一些技巧&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android中app.build配置</title>
    <link href="http://jiezhi.github.io/2017/10/18/gradle-in-android/"/>
    <id>http://jiezhi.github.io/2017/10/18/gradle-in-android/</id>
    <published>2017-10-18T07:40:29.000Z</published>
    <updated>2019-02-19T08:39:01.206Z</updated>
    
    <content type="html"><![CDATA[<p>备份一下项目中的app.build文件<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">release &#123;</span><br><span class="line">       minifyEnabled <span class="keyword">true</span></span><br><span class="line">       shrinkResources <span class="keyword">true</span></span><br><span class="line">       <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">       resValue "string", "app_name", "AppName"</span></span><br><span class="line"><span class="function">       resValue "string", "account_type", "io.jiezhi.app.type"</span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function">   preRelease </span>&#123;</span><br><span class="line">       debuggable <span class="keyword">true</span></span><br><span class="line">       jniDebuggable <span class="keyword">true</span></span><br><span class="line">       minifyEnabled <span class="keyword">true</span></span><br><span class="line">       zipAlignEnabled <span class="keyword">true</span></span><br><span class="line">       <span class="function">proguardFiles <span class="title">getDefaultProguardFile</span><span class="params">(<span class="string">'proguard-android.txt'</span>)</span>, 'proguard-rules.pro'</span></span><br><span class="line"><span class="function">       applicationIdSuffix ".pre"</span></span><br><span class="line"><span class="function">       resValue "string", "app_name", "AppName（Pre）"</span></span><br><span class="line"><span class="function">       resValue "string", "account_type", "io.jiezhi.app.type.pre"</span></span><br><span class="line"><span class="function">       versionNameSuffix '-pre'</span></span><br><span class="line"><span class="function">   &#125;</span></span><br><span class="line"><span class="function">   debug </span>&#123;</span><br><span class="line">       applicationIdSuffix <span class="string">".debug"</span></span><br><span class="line">       resValue <span class="string">"string"</span>, <span class="string">"app_name"</span>, <span class="string">"AppName（debug）"</span></span><br><span class="line">       resValue <span class="string">"string"</span>, <span class="string">"account_type"</span>, <span class="string">"io.jiezhi.app.type.debug"</span></span><br><span class="line">       versionNameSuffix <span class="string">'-debug'</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;备份一下项目中的app.build文件&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用注解改进Android代码</title>
    <link href="http://jiezhi.github.io/2017/05/07/annotations/"/>
    <id>http://jiezhi.github.io/2017/05/07/annotations/</id>
    <published>2017-05-07T12:38:31.000Z</published>
    <updated>2019-02-19T08:37:08.573Z</updated>
    
    <content type="html"><![CDATA[<p>注解有很多用途。 但是，在这里我们将讨论如何使用注解来改进我们的android编码。<br><a id="more"></a><br><img src="https://cdn-images-1.medium.com/max/800/1*gxjdLI-WsXSPWPvAyBAMaQ.png" alt=""></p><h2 id="注解即元数据"><a href="#注解即元数据" class="headerlink" title="注解即元数据"></a>注解即元数据</h2><p>而元数据是提供有关其他数据的信息的一组数据。</p><p>注解有很多用途。 但是，在这里我们将讨论如何使用注解来改进我们的android编码。</p><p>官方Android已经提供了支持注解，你可以添加如下依赖关系来导入注解：</p><blockquote><p>compile ‘com.android.support:support-annotations:x.x.x’</p></blockquote><p>每个人都想成为一个好的程序员，每天我也在努力地提高自己。</p><blockquote><p>任何人都可以编写计算机可以理解的代码，而好的程序员编写人可以理解的代码。 - Martin Fowler</p></blockquote><h2 id="让我们一起探索下一些有用的注解"><a href="#让我们一起探索下一些有用的注解" class="headerlink" title="让我们一起探索下一些有用的注解"></a>让我们一起探索下一些有用的注解</h2><h3 id="空类型注解"><a href="#空类型注解" class="headerlink" title="空类型注解"></a>空类型注解</h3><p><strong>@Nullable</strong>和<strong>@NonNull</strong>注解用于检查给定的变量、参数甚至是返回值是否为空。</p><p><strong>@Nullable</strong>：它表示一个变量、参数或返回值可以为空。</p><p><strong>@NonNUll</strong>：它表示不能为空的变量、参数或返回值。</p><p>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(@Nullable String s1, @NonNull String s2)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// s1 可以为空</span></span><br><span class="line">  <span class="comment">// s2 不可以为空</span></span><br><span class="line">  <span class="comment">// 该方法必须返回一个不为空的view</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以当我们尝试这样调用该方法时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">View view = getView(<span class="string">"Amit"</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>在代码检测期间，Android Studio会警告你s2的值不能为空。</p><h2 id="资源注解"><a href="#资源注解" class="headerlink" title="资源注解"></a>资源注解</h2><p>我们都知道，Android对资源的引用（如drawable和string资源）都是传递int类型的，因此我们必须验证资源类型。假设代码中希望传入特定类型的资源（例如Drawables），这里可以传入引用类型的<strong>int</strong>值，但实际上却传入了另外类型的资源，例如R.string资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(@StringRes <span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// resId 必须为string类型的id</span></span><br><span class="line">  <span class="comment">// resId 不能为常规的int值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，当你像如下方式调用该方法时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">textView.setText(<span class="number">56</span>);</span><br></pre></td></tr></table></figure><p>在代码检测过程中，当传入非string资源的参数时，注解将会生成一个警告。</p><h2 id="线程注解"><a href="#线程注解" class="headerlink" title="线程注解"></a>线程注解</h2><p>线程注解检查方法是否在其期望的线程被调用。</p><p>支持的注解有：</p><p><strong>@MainThread</strong><br><strong>@UiThread</strong><br><strong>@WorkerThread</strong><br><strong>@BinderThread</strong><br><strong>@AnyThread</strong></p><p>如果你添加如下的注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WorkerThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// 该方法一定要从worker线程调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你从非worker线程调用该方法时，你将会得到一个警告。</p><h2 id="值限定注解"><a href="#值限定注解" class="headerlink" title="值限定注解"></a>值限定注解</h2><p>有时候，我们必须对参数做一些约束，所以使用<strong>@IntRange</strong>，<strong>@FloatRange</strong>和<strong>@Size</strong>注解来验证传入参数的值。</p><p>当调用该方法的人可能会传递错误的值（超出指定的范围）时，该注解是非常有用的。</p><p>在下面的例子中，@IntRange注解确保传递的整数值必须在0到255之间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlpha</span><span class="params">(@IntRange(from=<span class="number">0</span>,to=<span class="number">255</span>)</span> <span class="keyword">int</span> alpha) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="权限注解"><a href="#权限注解" class="headerlink" title="权限注解"></a>权限注解</h2><p>使用<strong>@RequiresPermission</strong>注解来验证调用者的权限。</p><p>以下示例注解<strong>setWallpaper()</strong>方法来确保方法的调用者具有<strong>permission.SET_WALLPAPERS</strong>权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresPermission</span>(Manifest.permission.SET_WALLPAPER)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">setWallpaper</span><span class="params">(Bitmap bitmap)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><p>如果在调用该方法时没有在manifest文件中添加需要的权限，代码检测器将会给你一个警告。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;注解有很多用途。 但是，在这里我们将讨论如何使用注解来改进我们的android编码。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>android中的ArrayMap和SparseArray</title>
    <link href="http://jiezhi.github.io/2017/03/30/android-arraymap-vs-sparsearray/"/>
    <id>http://jiezhi.github.io/2017/03/30/android-arraymap-vs-sparsearray/</id>
    <published>2017-03-30T13:02:58.000Z</published>
    <updated>2019-02-19T08:36:01.831Z</updated>
    
    <content type="html"><![CDATA[<p>为了提高Android应用程序的性能，Android系统提供了专门为移动开发而设计的集合。</p><a id="more"></a><p>集合是软件开发中最常用的东西了。 一般来说，当需要将数据存储在键值对中时，我们想到的第一个数据结构就是HashMap。 它非常的灵活，因此它是存储键值对的数据结构的最优选择。</p><p><strong>因此，ArrayMap和SparseArray比使用HashMap有更高的内存效率。</strong></p><h2 id="HashMap原理"><a href="#HashMap原理" class="headerlink" title="HashMap原理"></a>HashMap原理</h2><p>HashMap基本上是HashMap.Entry对象的一个数组。 Entry是HashMap的内部类，它用来保存键值对。</p><p>当键值对被插入到HashMap中时，会计算出该键的hashCode，并将该值分配给EntryClass的hashCode变量。 通过该hashCode，我们可以获取该键值对在存储池中的索引。 如果存储池中已经存在了键值对，则将插入新的键值对，并把最后一个键值对指向这个新的键值对，这使得存储池成为一个链接列表。</p><p>从数组中检索值的时间效率为恒定时间或O(1)。 这意味着不管数组的大小，拉取数组中的任何元素时间都相同。 这可以通过使用散列函数来生成指定键的数组索引。</p><p>HashMap用于将整数键映射到对象。</p><p><img src="https://cdn-images-1.medium.com/max/800/1*lXkll8fb72OFk5NVVbi_wQ.png" alt=""></p><p>以下是创建HashMap和获取键和值的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt; String, String&gt; map = <span class="keyword">new</span> HashMap&lt; String, String&gt;();</span><br><span class="line">map.put(“Key1”, <span class="string">"Value1"</span>);</span><br><span class="line">map.put(“Key2”, <span class="string">" Value2"</span>);</span><br><span class="line">map.put(“Key3”, <span class="string">" Value3"</span>);</span><br><span class="line"></span><br><span class="line">Set set = hmap.entrySet();</span><br><span class="line">Iterator iterator = set.iterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate over HashMap</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    Map.Entry mEntry = (Map.Entry)iterator.next();</span><br><span class="line">    String key = mEntry.getKey();</span><br><span class="line">    String value = mEntry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ArrayMap原理"><a href="#ArrayMap原理" class="headerlink" title="ArrayMap原理"></a>ArrayMap原理</h2><p>不像HashMap中包含一个数组，ArrayMap中包含了两个小数组。 第一个数组（Hash-Array）按顺序包含指定的哈希键。 第二个数组（Key Value Array）根据第一个数组存储对象的键和值。</p><p>当我们搜索其中的内容时，将会在Hash-Array上完成二分查找，通过找到的哈希索引，然后直接从第二个数组（Key Value Array）返回键值对。 如果第二个数组（Key Value Array）中的键不匹配，则通过第二个数组（Key Value Array）完成线性遍历来解决冲突。<br><img src="https://cdn-images-1.medium.com/max/800/1*v1_3ug_tpscGtYc7JxP2Og.png" alt=""></p><p>以下是创建ArrayMap和获取键和值的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayMap&lt;String, String&gt; arrayMap = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">arrayMap.put(“Key1”, “Value1”);</span><br><span class="line">arrayMap.put(“Key2”, “Value2”);</span><br><span class="line">arrayMap.put(“Key3”, “Value3”);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayMap.size(); i++) &#123;</span><br><span class="line">    String key = arrayMap.keyAt(i);</span><br><span class="line">    String value = arrayMap.valueAt(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SparseArray原理"><a href="#SparseArray原理" class="headerlink" title="SparseArray原理"></a>SparseArray原理</h2><p>与ArrayMap的主要区别在于，在SparseArray键中始终是原始类型。 在其他方面的操作原理是相似的。 当键是原始类型时，稀疏数组（Sparse arrays）可用于替换哈希映射（hash maps）。 SparseArray旨在消除自动装箱的问题（ArrayMap不能避免自动装箱问题），而这种方法会影响内存消耗。</p><p>以下是创建SparseArray的示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SparseArray sparseArray = <span class="keyword">new</span> SparseArray();</span><br><span class="line">sparseArray.put(<span class="number">1</span>, “Value1”);</span><br><span class="line"></span><br><span class="line">SparseLongArray sparseLongArray = <span class="keyword">new</span> SparseLongArray();</span><br><span class="line">sparseLongArray.put(<span class="number">1</span>, <span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">SparseBooleanArray sparseBooleanArray = <span class="keyword">new</span> SparseBooleanArray();</span><br><span class="line">sparseBooleanArray.put(<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">SparseIntArray sparseIntArray = <span class="keyword">new</span> SparseIntArray();</span><br><span class="line">sparseIntArray.put(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p><p>该类在API 1中已经存在了，但在API 11中经过了重新设计。兼容库中的更新版本的SparseArrayCompat也可用于较旧设备。</p><p>还有几种其他类型的SparseArray：</p><p><em>LongSparseArray，SparseIntArray，SparseBooleanArray</em>等<br>HashMap可以被以下的Array类替换：</p><p><img src="https://cdn-images-1.medium.com/max/800/1*7FOi8twIY2LmDCpM-rOtwg.png" alt=""></p><h2 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h2><p>内存的连续分配和回收以及垃圾收集将导致Android应用程序的滞后，从而降低了应用程序的性能。 除此之外，ArrayMap＆SparseArray通过使用2个小数组而不是一个大的数组来避免内存问题。</p><h3 id="使用SparseArray比使用HashMap的好处是："><a href="#使用SparseArray比使用HashMap的好处是：" class="headerlink" title="使用SparseArray比使用HashMap的好处是："></a>使用SparseArray比使用HashMap的好处是：</h3><ul><li>使用原语（primitives）带来更多的内存效率</li><li>没有自动装箱操作</li><li>自由分配内存</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3><ul><li>对于大集合，速度较慢</li><li>仅适用于Android</li></ul><p>一般来说，如果没有频繁的插入或删除操作，且大小是小于1000，那么ArrayMap / SparseArray类是非常好的选择。</p><p>来自Android开发者的视频将为您提供进一步的细节：<br><img src="https://youtu.be/ORgucLTtTDI" alt=""></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>我们可以得出结论，将整数映射到对象，SparseArray比使用HashMap的更有效。 理论是SparseArray可以比HashMap（&lt;1000）更快地添加和检索元素，在这种情况下，减少了哈希函数处理时间。</p><blockquote><p>原文地址：<a href="https://android.jlelse.eu/app-optimization-with-arraymap-sparsearray-in-android-c0b7de22541a" target="_blank" rel="noopener">https://android.jlelse.eu/app-optimization-with-arraymap-sparsearray-in-android-c0b7de22541a</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了提高Android应用程序的性能，Android系统提供了专门为移动开发而设计的集合。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://jiezhi.github.io/categories/Android/"/>
    
    
      <category term="android" scheme="http://jiezhi.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【译】Android Studio 技巧8 —— Json模型</title>
    <link href="http://jiezhi.github.io/2017/03/21/android-studio-tip8/"/>
    <id>http://jiezhi.github.io/2017/03/21/android-studio-tip8/</id>
    <published>2017-03-21T12:58:31.000Z</published>
    <updated>2019-02-19T08:36:48.349Z</updated>
    
    <content type="html"><![CDATA[<p>最近JSON对象非常受欢迎。那让我们看看如何对他们建模。<br><a id="more"></a></p><p>试想一下，你的后端团队给了你一个你期望的JSON示例。 分析过后，你尝试建立POJO模型，所以你通过众多的第三方库简单地进行注入（例如<a href="https://github.com/google/gson" target="_blank" rel="noopener">gson</a>）。 你花了很多时间来创建表示json的每个单个实体的POJO。 这非常无聊而且浪费了大量的时间。 部分人可能会使用<a href="http://www.jsonschema2pojo.org/" target="_blank" rel="noopener">json2pojo</a>网站，但你仍然必须手动将生成的类放入到你的包，而且可能变得很混乱。</p><p>让我们看一个不错的插件，可以更高效地处理这个过程。</p><hr><h3 id="RoboPOJOGenerator"><a href="#RoboPOJOGenerator" class="headerlink" title="RoboPOJOGenerator"></a><a href="https://plugins.jetbrains.com/plugin/8634-robopojogenerator" target="_blank" rel="noopener">RoboPOJOGenerator</a></h3><p>它支持从模式(schema)或从实际的JSON数据中生成POJO模型。 它还可以生成支持gson，Jackson，LoganSquare和AutoValueGson方案的对象，因此您可以使用任何种类的库来解析。 它还支持<em>Kotlin</em>，这是一个非常好的功能。它还会问你是否要生成<em>toString</em>和<em>getters＆setters</em>方法。<br><img src="https://cdn-images-1.medium.com/max/800/1*YoEqqnUgEcJDyFgu6_KLgw.gif" alt=""></p><hr><p>我希望这将帮助你加快开发过程，并且减少无聊的工作量！ 敬请关注下一篇文章！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近JSON对象非常受欢迎。那让我们看看如何对他们建模。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://jiezhi.github.io/categories/Android/"/>
    
    
      <category term="android" scheme="http://jiezhi.github.io/tags/android/"/>
    
      <category term="json" scheme="http://jiezhi.github.io/tags/json/"/>
    
      <category term="plugin" scheme="http://jiezhi.github.io/tags/plugin/"/>
    
  </entry>
  
  <entry>
    <title>【译】android studio 技巧1——Parcelable</title>
    <link href="http://jiezhi.github.io/2017/03/19/android-studio-tip1/"/>
    <id>http://jiezhi.github.io/2017/03/19/android-studio-tip1/</id>
    <published>2017-03-19T07:49:25.000Z</published>
    <updated>2019-02-19T08:36:36.174Z</updated>
    
    <content type="html"><![CDATA[<p>最后，我决定开始我自己的技术博客。首先发布一系列的帖子来描述一些我每天开发都在使用的Android Studio插件。</p><a id="more"></a><p>如果你不知道如何在Android Studio中安装插件，请点击此<a href="http://stackoverflow.com/a/30617737/2855514" target="_blank" rel="noopener">链接</a>。</p><h3 id="Android-Parcelable代码生成器"><a href="#Android-Parcelable代码生成器" class="headerlink" title="Android Parcelable代码生成器"></a><a href="https://plugins.jetbrains.com/idea/plugin/7332-android-parcelable-code-generator" target="_blank" rel="noopener">Android Parcelable代码生成器</a></h3><p>你是否有过必须在两个Activity/Fragment之间转发数据情况？</p><p>如果是的话，你应该熟悉Bundle类的用法，你也知道你只能在其中放置一个特定类型的项目。</p><p>但是如果我想转发整个对象呢？ 那么，该对象将需要实现Serializable或Parcelable接口。 第一种方式对于开发人员还算简单，在第一个实例中，我们似乎要用这种方式。 但是，正如这个<a href="http://www.developerphil.com/parcelable-vs-serializable/" target="_blank" rel="noopener">帖子</a>解释的，使用Parcelable接口是更有效率的。 不过它的缺点是需要写一点代码，而且可能不是那么直观。<br><img src="https://cdn-images-1.medium.com/max/1600/1*VCvqU-RYvueGkL8G9Btc7w.png" alt=""><br>这是“Android Parcelable代码生成器”插件所做的。 你可以让这个插件生成实现Parcelable接口所需的代码。</p><p>具体怎么做呢，请往下看：<br><img src="https://cdn-images-1.medium.com/max/1600/1*hN7MZbTTNY8ZUYwVSsqEbQ.gif" alt=""></p><h2 id="如果有人使用Kotliin的话，这里也有一款插件可以使用：Parcelable-Code-Generator-for-kotlin"><a href="#如果有人使用Kotliin的话，这里也有一款插件可以使用：Parcelable-Code-Generator-for-kotlin" class="headerlink" title="如果有人使用Kotliin的话，这里也有一款插件可以使用：Parcelable Code Generator(for kotlin)"></a>如果有人使用Kotliin的话，这里也有一款插件可以使用：<a href="https://plugins.jetbrains.com/idea/plugin/8086-parcelable-code-generator-for-kotlin-" target="_blank" rel="noopener">Parcelable Code Generator(for kotlin)</a></h2><p>敬请关注下一篇文章！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后，我决定开始我自己的技术博客。首先发布一系列的帖子来描述一些我每天开发都在使用的Android Studio插件。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://jiezhi.github.io/categories/Android/"/>
    
    
      <category term="android" scheme="http://jiezhi.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【译】Android Studio 技巧2——资源和图标</title>
    <link href="http://jiezhi.github.io/2017/03/19/android-studio-tip2/"/>
    <id>http://jiezhi.github.io/2017/03/19/android-studio-tip2/</id>
    <published>2017-03-19T06:16:21.000Z</published>
    <updated>2019-02-19T08:36:42.278Z</updated>
    
    <content type="html"><![CDATA[<p>这是我的第二篇帖子。 今天我要讨论一下资源，特别是图标这块。</p><a id="more"></a><hr><h3 id="Android-Drawable-Importer"><a href="#Android-Drawable-Importer" class="headerlink" title="Android Drawable Importer"></a><a href="https://plugins.jetbrains.com/idea/plugin/7658-android-drawable-importer" target="_blank" rel="noopener">Android Drawable Importer</a></h3><p>作为Android开发人员，你应该在drawable文件夹中手动地导入过很多图标了。</p><p>有些聪明的设计师给你的资源已经按照正确的命名放在了正确的文件夹中了，这会简化你很多的工作。但有时候你可能要重命名和手动移动每个PNG文件到相关的drawable文件夹中。 这会花费你一些时间，些许苦恼。 我非常想把这时间用在别的事情上，那我们如何改进它并停止浪费时间呢？</p><p>“Android Drawable Importer”这款插件将会帮助到你。 它主要有4个主要特点：</p><ul><li>批量导入资源</li><li>导入图标资源包</li><li>导入矢量资源</li><li>多分辨率（Multisource）资源</li></ul><hr><h3 id="批量导入资源"><a href="#批量导入资源" class="headerlink" title="批量导入资源"></a><strong>批量导入资源</strong></h3><p>这是个非常有用的特性，顾名思义，就是导入一批drawable。 假设你有5个只有一种分辨率的不同的图标，你可以一次把他们导入到指定分辨率的文件夹中。 如果你想的话，它还创建其他的png的drawable文件夹。<br><img src="https://cdn-images-1.medium.com/max/800/1*ZKrIWeTY5cSM04u74chx6w.gif" alt=""></p><h3 id="导入图标资源包"><a href="#导入图标资源包" class="headerlink" title="导入图标资源包"></a><strong>导入图标资源包</strong></h3><p><em>导入图标资源包</em>允许你从预定义资源集合中导入图标，而且你还可以指定其大小，颜色，格式和尺寸。<br><img src="https://cdn-images-1.medium.com/max/800/1*7CAEuZjGeDRuYcUy8iBx0A.gif" alt=""></p><p>这已经不是特别有用了，因为Android Studio集成了一个名为<a href="https://developer.android.com/studio/write/image-asset-studio.html" target="_blank" rel="noopener">Image Asset Studio</a>的功能，通过官方的这个插件你可以做同样或更多的事。 例如，你可以将文本作为资源导出，或者你可以用来处理图片。<br><img src="https://cdn-images-1.medium.com/max/800/1*Qb-T5WtUcvMDlo2v7zfefg.gif" alt=""></p><h3 id="导入矢量资源"><a href="#导入矢量资源" class="headerlink" title="导入矢量资源"></a><strong>导入矢量资源</strong></h3><p><em>导入矢量资源</em>使你能够从给定的集合导入矢量资源。 Android Studio已经集成了一个名为<a href="https://developer.android.com/studio/write/vector-asset-studio.html" target="_blank" rel="noopener">Vector Asset Studio</a>的类似工具。 此外，它还允许你从给定的SVG或PSD导入向量。 我建议在这种情况下使用集成工具而不是插件。</p><h3 id="多分辨率资源"><a href="#多分辨率资源" class="headerlink" title="多分辨率资源"></a><strong>多分辨率资源</strong></h3><p>最后但同样重要的是，<em>多分辨率资源</em>。 你可以为每个导入的资源的不同分辨率指定为不同图标。 如果你需要根据屏幕分辨率使用不同的图标，或者如果你在不同的文件夹中有同样的图标，并且想要立即导入所有图标，这个可能非常有用。<br><img src="https://cdn-images-1.medium.com/max/800/1*kisvCgiv-_DgO85mntwWNw.gif" alt=""></p><hr><p>本文到此结束。 如果有想法请留下你的评论！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是我的第二篇帖子。 今天我要讨论一下资源，特别是图标这块。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://jiezhi.github.io/categories/Android/"/>
    
    
      <category term="android" scheme="http://jiezhi.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>【译】Android Studio 贴士 3— FindViewById</title>
    <link href="http://jiezhi.github.io/2017/03/16/android-studio-findviewbyid/"/>
    <id>http://jiezhi.github.io/2017/03/16/android-studio-findviewbyid/</id>
    <published>2017-03-16T12:52:38.000Z</published>
    <updated>2019-02-19T08:36:29.870Z</updated>
    
    <content type="html"><![CDATA[<p>今天，我们讨论一下View。让我们谈谈如何快速地从xml布局文件中获取到定义好的View实例。<br><a id="more"></a></p><p>本文翻译自<a href="https://android.jlelse.eu/@fedestylah?source=post_header_lockup" target="_blank" rel="noopener">Federico Palmieri</a> 的<a href="https://android.jlelse.eu/android-studio-tips-for-productivity-3-a87e84ca6f62" target="_blank" rel="noopener">文章</a>。</p><hr><p>我很确定每个Android开发人员都会很快就开始厌烦，为layout文件中的View编写findviewbyid的重复动作。如果你不厌烦它，那么让我们尝试另一种方式，来避免浪费时间！</p><p>有些人可能使用<a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="noopener">ButterKnife</a>来避免findviewbyid后的转换（可能还有其他一些原因）。即使这样，它也不会减轻给每个的id加注解的痛苦。</p><p>有多少次你从xml布局和你的java代码来回切换，只是因为你忘了一个view的id？让我们放弃这种方式吧！</p><p>我们有两种不同的方式可以使用，无论你使用简单的findviewbyid还是使用ButterKnife。</p><hr><p>使用ButterKnife<br>如果你是ButterKnife的用户，那么你可能要学习下Android ButterKnife Zelezny。</p><p><a href="https://plugins.jetbrains.com/idea/plugin/7369-android-butterknife-zelezny" target="_blank" rel="noopener">Android ButterKnife Zelezny</a></p><p>这个插件将允许你简单地生成ButterKnife注解，而对于Activity和Fragment，它也将添加ButterKnife.bind(…)方法的调用。在View中，则需要你自己添加该调用。</p><ul><li><p>Activity<br><img src="https://cdn-images-1.medium.com/max/1600/1*u1c9R8_uDr75A8QO3FdSbQ.gif" alt=""></p></li><li><p>Fragment<br><img src="https://cdn-images-1.medium.com/max/1600/1*XyXCOv5S-sFrejQPfgaVaw.gif" alt=""></p></li><li><p>View<br><img src="https://cdn-images-1.medium.com/max/1600/1*7JNg8td1MVHzTuzH6EVF6w.gif" alt=""></p></li></ul><hr><p>不使用ButterKnife<br>如果你不使用ButterKnife，那么你可能需要考虑使用FindViewByMe。</p><p><a href="https://plugins.jetbrains.com/idea/plugin/8261-findviewbyme" target="_blank" rel="noopener">FindViewByMe</a></p><p>编辑：我之前向该仓库中推送对Fragment和自定义View的支持，如今，开发人员发布了解决下面提到的问题的插件的v1.3.5。 我将相应地更新GIF。</p><p>这个很棒的插件仍然在开发中，目前还不能很好地支持Fragment和自定义view。 在Activity中，它将为你执行一切，而无需手动定义和赋值布局文件中的view。 在Fragment和自定义view中，您将需要稍微更多的努力。</p><ul><li>Activity<br><img src="https://cdn-images-1.medium.com/max/1600/1*BTURA408x-3YQzxL-KWbZQ.gif" alt=""></li></ul><p>如前所述，它不能很好地与Fragment工作，但我们任然可以使它工作。 你需要重写onCreate，因为插件只能在onCreate方法中调用生成代码来工作。</p><ul><li>Fragment (Hexo插入视频可能有问题，可以点击链接查看)<br><a href="https://youtu.be/fppaDGgpScc" target="_blank" rel="noopener">油管视频</a></li></ul><video src="https://youtu.be/xSgrrmBugZc" type="video/mp4" controls="controls" width="100%" height="100%"></video><p>在视图中，它的工作原理与Fragment中的几乎相同。 你不能重写onCreate，但你可以通过创建一个假的onCreate()方法来作弊。</p><ul><li>View<br><a href="https://youtu.be/fppaDGgpScc" target="_blank" rel="noopener">油管视频</a><video src="https://youtu.be/fppaDGgpScc" type="video/mp4" controls="controls" width="100%" height="100%"></video></li></ul><p>你可以帮助这个插件的开发者继续改进它，并通过fork该<a href="https://github.com/laobie/FindViewByMe" target="_blank" rel="noopener">仓库</a>来解决上述问题。</p><hr><p>感谢，和往常一样，请让我知道你的意见！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天，我们讨论一下View。让我们谈谈如何快速地从xml布局文件中获取到定义好的View实例。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://jiezhi.github.io/categories/Android/"/>
    
    
      <category term="android" scheme="http://jiezhi.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>6行脚本获取Google Voice</title>
    <link href="http://jiezhi.github.io/2017/03/12/get-google-voice/"/>
    <id>http://jiezhi.github.io/2017/03/12/get-google-voice/</id>
    <published>2017-03-12T13:14:41.000Z</published>
    <updated>2019-02-19T08:38:45.744Z</updated>
    
    <content type="html"><![CDATA[<p>Google Voice（简称GV）在程序员的圈子里也不算太陌生了，尤其是经常混V站的人应该经常见到这货的出现。不清楚的可以关掉或者先自行Google了。</p><a id="more"></a><p>如果你上网查教程，其实很简单无非使用类似TextNow/TextMe等先申请个美国的号码，然后绑定Google账号，再从Google申请个Voice号码即可。步骤也不多，但很多人Google Voice号码都选好了，可就是点击申请会一直出现『请求错误』的提示。据报道称，解决这个问题的唯一途径就是『狂点大法』——不停地点，运气好5分钟或半小时就能申请到好，也有运气不好，需要一天甚至更多的时间来点击申请。所以有的人就放弃了，或者直接去马云家直接花几十块钱买了。</p><p>目前实现这个『狂点大法』的无非两种途径，模拟鼠标点击和模拟网络请求。</p><p>模拟鼠标点击：<br>顾名思义就是不停地让鼠标在申请按钮上点击，直到你收到Google 邮件恭喜你获得了号码为止。这种很多人会使用『按键精灵』类似的软件来实现不停地点击。但是我选择了自己写python脚本来模拟点击，毕竟自己写的代码才放心。<a href="https://gist.github.com/Jiezhi/aad8a37114825b0ce1a5bc48bf5f3cac" target="_blank" rel="noopener">代码</a>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pymouse <span class="keyword">import</span> PyMouse</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">m = PyMouse()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    m.click(<span class="number">528</span>, <span class="number">800</span><span class="number">-196</span>, <span class="number">1</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>其中点击的坐标要改成你自己的，可使用截屏工具来获得按钮的坐标。</p><p>模拟网络请求：<br>这个方法就是直接跳过点击事件，毕竟你点击了也是通过网络请求来实现的。这样子更彻底点，这里粗略地介绍个思路：</p><p>打开浏览器的开发模式（F12）<br>点击网页上的申请按钮<br>找到本次post请求，然后右键复制cURL<br>把cURL请求扔到脚本里，找个服务器或者自己电脑终端里在后台运行即可<br>这个我也放出个<a href="https://gist.github.com/Jiezhi/d02c46449dda06ed0866757bc7ea92c2" target="_blank" rel="noopener">shell 脚本</a>吧：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (( i=1; i&gt;0; i++ ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    curl <span class="string">'https://www.google.com/voice/b/0/service/post'</span> ... --compressed</span><br><span class="line"></span><br><span class="line">    sleep 3s</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>如果你需要帮助可以在博客下方留言即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Google Voice（简称GV）在程序员的圈子里也不算太陌生了，尤其是经常混V站的人应该经常见到这货的出现。不清楚的可以关掉或者先自行Google了。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>你好2017</title>
    <link href="http://jiezhi.github.io/2017/03/09/2016-summary/"/>
    <id>http://jiezhi.github.io/2017/03/09/2016-summary/</id>
    <published>2017-03-09T12:28:27.000Z</published>
    <updated>2019-02-19T08:35:06.627Z</updated>
    
    <content type="html"><![CDATA[<p>似乎我的2017来的有点迟啊。</p><a id="more"></a><p>翻一下自己的博客，上一篇还停留在2016年9月29日，还像个综述。</p><p>除了博客荒废了之外，去年也还少了一份总结。正如去个景点不拍个照就跟没去似的，一年不来个总结就感觉一年就跟白过了一样，然而暂时我也不想去过多总结了，就先随便总结下吧。</p><p>总之去年4月底离开了老东家去三亚浪了一圈，在下半年来到了现在这家公司——『让农业经营更容易』。刚到公司就在赶项目，加之又被阿飞他们带了一个小学生特别多的游戏，所以书读的少了。基本就是晚上加班回去和出差的路上零星读了几本书，然后也没记录到我的<a href="https://github.com/Jiezhi/Jiezhi-Life/blob/master/2016/book2016.md" target="_blank" rel="noopener">书单</a>上了。</p><p>此外，也在去年年中的时候加入了Google字幕组，帮忙翻译一些Google的开发教学视频的字幕，去年翻的时长差不多80分钟吧。但实在是被我的懒癌整的这阶段又不是太想去接视频翻字幕了，还是等今年I/O大会结束再去接点视频翻吧。所幸，读书荒废之外，还保持着每天学英语的习惯，背几十个单词或读几篇新闻亦或几条听力，时多时少，最重要的是我坚持下来了。</p><p>年后过来项目算是轻松点了，除了沉迷游戏外还是能挤出点时间的。最近一直看国外的<a href="https://medium.com" target="_blank" rel="noopener">medium</a>博客上有不少优秀的技术文章，心又痒了，想平时没事也可以翻译一点。遂捡起老早前注册但没发过文章的公众号，于昨天打响了文章第一枪。</p><p>今天想干脆一不做二不休，把这hexo博客再拿起来维护着吧，不管看的人多少，起码是自己风流倜傥的过往！</p><p>之前域名过期了，也懒得续费了，还是直接用github的地址吧：<a href="http://jiezhi.github.io">http://jiezhi.github.io</a> 欢迎打赏丢香蕉给我。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;似乎我的2017来的有点迟啊。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>DHT 相关资源整理</title>
    <link href="http://jiezhi.github.io/2016/09/29/dht-resources/"/>
    <id>http://jiezhi.github.io/2016/09/29/dht-resources/</id>
    <published>2016-09-29T07:18:14.000Z</published>
    <updated>2019-02-19T08:37:59.751Z</updated>
    
    <content type="html"><![CDATA[<p>想自己实现一个DHT爬虫，这里先收集一些资源<br><a id="more"></a></p><ul><li><p><a href="https://github.com/xiaojiong/DhtCrawler" target="_blank" rel="noopener">GO语言实现的DHT网络爬虫</a></p></li><li><p><a href="http://www.cnblogs.com/huangxie/p/5550680.html" target="_blank" rel="noopener">python语言磁力搜索引擎源码公开，基于DHT协议</a></p></li><li><p><a href="http://btlike.com/" target="_blank" rel="noopener">btlike BT搜索引擎</a></p></li><li><p><a href="https://github.com/bmuller/kademlia" target="_blank" rel="noopener">A DHT in Python Twisted</a></p></li></ul><hr><p>搜索资源：</p><ul><li><a href="https://www.google.com/search?newwindow=1&amp;q=site%3Av2ex.com%2Ft+dht&amp;oq=site%3Av2ex.com%2Ft+dht" target="_blank" rel="noopener">v2ex</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想自己实现一个DHT爬虫，这里先收集一些资源&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>tmux初步入门</title>
    <link href="http://jiezhi.github.io/2016/09/29/hello-tmux/"/>
    <id>http://jiezhi.github.io/2016/09/29/hello-tmux/</id>
    <published>2016-09-29T07:04:17.000Z</published>
    <updated>2019-02-19T08:39:25.565Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下常用的tmux命令<br><a id="more"></a></p><ul><li><p>Create Named Sessions</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tmux new-session -s basic</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">tmux new -s basic</span><br></pre></td></tr></table></figure></li><li><p>detach session</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PREFIX d</span><br></pre></td></tr></table></figure></li><li><p>Retattaching to Existing Sessions</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tmux list-sessions</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">tmux ls</span><br></pre></td></tr></table></figure></li><li><p>Attach to Sessions</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux attach -t basic</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下常用的tmux命令&lt;br&gt;
    
    </summary>
    
      <category term="tools" scheme="http://jiezhi.github.io/categories/tools/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 在style.xml文件中设置match_parent 和 wrap_content</title>
    <link href="http://jiezhi.github.io/2016/07/14/android-set-match-parend-in-style-file/"/>
    <id>http://jiezhi.github.io/2016/07/14/android-set-match-parend-in-style-file/</id>
    <published>2016-07-14T07:49:02.000Z</published>
    <updated>2019-02-19T08:36:23.033Z</updated>
    
    <content type="html"><![CDATA[<p>在style文件中直接设置android:width值为wrap_content的话会报错:</p><pre><code>Cannot resolve symbol &apos;wrap_content&apos;</code></pre><p>那该如何解决？</p><a id="more"></a><p>一般情况下，我们会把界面中共用的一些属性直接定义在style.xml文件中，但是在设置View的高度和宽度时，如果想用wrap_content和match_parent的话，则需要先定义一下：</p><p>在<strong>dimmens.xml</strong>文件中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"match_parent"</span>&gt;</span>-1dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">"wrap_content"</span>&gt;</span>-2dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在<strong>style.xml</strong>文件中直接引用即可，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">"begin_medium_text"</span> <span class="attr">parent</span>=<span class="string">"medium_text"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:gravity"</span>&gt;</span>end|center_vertical<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:width"</span>&gt;</span>@dimen/wrap_content<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"android:height"</span>&gt;</span>@dimen/match_parent<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Reference: <a href="http://stackoverflow.com/questions/6859331/how-can-i-use-layout-width-using-resource-file" target="_blank" rel="noopener">http://stackoverflow.com/questions/6859331/how-can-i-use-layout-width-using-resource-file</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在style文件中直接设置android:width值为wrap_content的话会报错:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cannot resolve symbol &amp;apos;wrap_content&amp;apos;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那该如何解决？&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://jiezhi.github.io/categories/Android/"/>
    
    
      <category term="android" scheme="http://jiezhi.github.io/tags/android/"/>
    
      <category term="View" scheme="http://jiezhi.github.io/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>解决adb无法找到genymotion模拟器问题</title>
    <link href="http://jiezhi.github.io/2016/05/23/adb-with-genymotion-error/"/>
    <id>http://jiezhi.github.io/2016/05/23/adb-with-genymotion-error/</id>
    <published>2016-05-23T13:33:05.000Z</published>
    <updated>2019-02-19T08:35:01.997Z</updated>
    
    <content type="html"><![CDATA[<p>今天升级了一下Android SDK结果开着genymotion模拟器的情况下却找不到设备。<br><a id="more"></a><br>用<code>adb devices</code>查看会出现如下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ adb devices</span><br><span class="line">List of devices attached</span><br><span class="line">adb server version (32) doesn<span class="string">'t match this client (35); killing...</span></span><br><span class="line"><span class="string">error: could not install *smartsocket* listener: Address already in use</span></span><br><span class="line"><span class="string">ADB server didn'</span>t ACK</span><br><span class="line">* failed to start daemon *</span><br><span class="line">error: cannot connect to daemon</span><br></pre></td></tr></table></figure><p>看了是adb版本的问题了，在genymotion中有个设置成你自己的sdk地址即可，重启模拟器后即可：<br><img src="genymotion-settings.png" alt=""></p><p><em>Reference：<a href="https://twitter.com/chiuki/status/709410135551168512" target="_blank" rel="noopener">https://twitter.com/chiuki/status/709410135551168512</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天升级了一下Android SDK结果开着genymotion模拟器的情况下却找不到设备。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://jiezhi.github.io/categories/Android/"/>
    
    
      <category term="android" scheme="http://jiezhi.github.io/tags/android/"/>
    
      <category term="adb" scheme="http://jiezhi.github.io/tags/adb/"/>
    
      <category term="genymotion" scheme="http://jiezhi.github.io/tags/genymotion/"/>
    
  </entry>
  
  <entry>
    <title>使用Decorator设计Cache</title>
    <link href="http://jiezhi.github.io/2016/04/20/decorator4cache/"/>
    <id>http://jiezhi.github.io/2016/04/20/decorator4cache/</id>
    <published>2016-04-20T07:53:35.000Z</published>
    <updated>2019-02-19T08:37:51.071Z</updated>
    
    <content type="html"><![CDATA[<p>利用decorator实现cache<br><a id="more"></a><br>如果你使用的是python 3.2+，则可以直接使用functools中的lru_cache。<br>当然也可以自己实现的了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on 4/20/16</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: Jiezhi.G@gmail.com</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">My Blog: jiezhi.github.io</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Reference: &lt;Expert Python Programming&gt; Chapter 2--Decorators_Proxy Page.53</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_obsolete</span><span class="params">(entry, duration)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> time.time() - entry[<span class="string">'time'</span>] &gt; duration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_key</span><span class="params">(function, args, kw)</span>:</span></span><br><span class="line">    key = pickle.dumps((function.func_name, args, kw))</span><br><span class="line">    <span class="keyword">return</span> hashlib.sha1(key).hexdigest()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memoize</span><span class="params">(duration=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_memoize</span><span class="params">(function)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__memoize</span><span class="params">(*args, **kw)</span>:</span></span><br><span class="line">            key = compute_key(function, args, kw)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># do we have it already?</span></span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> cache <span class="keyword">and</span> <span class="keyword">not</span> is_obsolete(cache[key], duration):</span><br><span class="line">                <span class="keyword">print</span> <span class="string">'we got a winner'</span></span><br><span class="line">                <span class="keyword">return</span> cache[key][<span class="string">'value'</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># computing</span></span><br><span class="line">            result = function(*args, **kw)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># storing the result</span></span><br><span class="line">            cache[key] = &#123;<span class="string">'value'</span>: result, <span class="string">'time'</span>: time.time()&#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> __memoize</span><br><span class="line">    <span class="keyword">return</span> _memoize</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@memoize()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">very_very_very_complex_stuff</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> very_very_very_complex_stuff(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> cache</span><br><span class="line">    <span class="keyword">print</span> very_very_very_complex_stuff(<span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>运行后可以看到结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">&#123;<span class="string">'dedfca39c250ca2047c5d66a13c5df2e9ac90181'</span>: &#123;<span class="string">'value'</span>: 4, <span class="string">'time'</span>: 1461155366.249486&#125;&#125;</span><br><span class="line">we got a winner</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用decorator实现cache&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="http://jiezhi.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://jiezhi.github.io/tags/python/"/>
    
      <category term="Decorator" scheme="http://jiezhi.github.io/tags/Decorator/"/>
    
      <category term="cache" scheme="http://jiezhi.github.io/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>python监测服务器 异常后发邮件</title>
    <link href="http://jiezhi.github.io/2016/03/20/send-mail-with-python/"/>
    <id>http://jiezhi.github.io/2016/03/20/send-mail-with-python/</id>
    <published>2016-03-20T13:58:31.000Z</published>
    <updated>2019-02-19T08:41:47.343Z</updated>
    
    <content type="html"><![CDATA[<p>最近写了个python脚本来监控服务器，结合crontab定时任务来定期检查服务器是否可以正常访问。</p><a id="more"></a><p>这里服务器给定一个固定url，服务器端监测数据库表是否正常，如果正常直接给出「ok」的回复。<br>里面逻辑也很简单直接上代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Author: Jiezhi.G@gmail.com</span></span><br><span class="line"><span class="string">Function: Monitor server and send mail when server down!</span></span><br><span class="line"><span class="string">Date: 2016-03-18</span></span><br><span class="line"><span class="string">PS: You can add this msg to cron:</span></span><br><span class="line"><span class="string">* 9,21 * * * python ~/monitor.py &gt;&gt; ~/monitor.log</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"></span><br><span class="line">sender_mail = <span class="string">"***"</span></span><br><span class="line">password = <span class="string">'***'</span></span><br><span class="line">receiver = [<span class="string">'***'</span>, <span class="string">'***'</span>, <span class="string">'***'</span>]</span><br><span class="line">smtp_server = <span class="string">"smtp.yeah.net"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_alert_mail</span><span class="params">()</span>:</span></span><br><span class="line">    msg = MIMEText(<span class="string">'服务器异常，请检查服务器!'</span>, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    msg[<span class="string">'Subject'</span>] = <span class="string">'!!!服务器异常'</span></span><br><span class="line">    msg[<span class="string">'From'</span>] = <span class="string">'Monitor&lt;***&gt;'</span></span><br><span class="line">    server = smtplib.SMTP(smtp_server, <span class="number">25</span>)</span><br><span class="line">    server.login(sender_mail, password)</span><br><span class="line">    server.sendmail(sender_mail, receiver, msg.as_string())</span><br><span class="line">    server.quit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_server</span><span class="params">(url)</span>:</span></span><br><span class="line">    ret = urllib2.urlopen(urllib2.Request(url))</span><br><span class="line">    data = ret.read()</span><br><span class="line">    <span class="keyword">return</span> data == <span class="string">"ok"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url_ch = <span class="string">'http://zh.example.com/api/isok.php'</span></span><br><span class="line">    url_en = <span class="string">'http://en.examp.com/api/isok.php'</span></span><br><span class="line">    t = time.strftime(<span class="string">"%Y-%m-%d %A %X %Z"</span>, time.localtime())</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> check_server(url_ch):</span><br><span class="line">        <span class="keyword">print</span> t, <span class="string">'server down'</span></span><br><span class="line">        send_alert_mail()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> t, <span class="string">'every thing is ok'</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近写了个python脚本来监控服务器，结合crontab定时任务来定期检查服务器是否可以正常访问。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="http://jiezhi.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://jiezhi.github.io/tags/python/"/>
    
      <category term="monitor" scheme="http://jiezhi.github.io/tags/monitor/"/>
    
      <category term="email" scheme="http://jiezhi.github.io/tags/email/"/>
    
  </entry>
  
</feed>
